 排序算法
## 内部排序
数据都在内存中
==关注如何使算法时、空复杂度更低==
## 外部排序
数据太多，无法全部放入内存中
还要关注如何使读/写磁盘次数更少
# 插入排序
## 算法思想
每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。
## 算法实现
![image.png|200](https://blog-1310087999.cos.ap-nanjing.myqcloud.com/20230929172225.png)
```C
//直接插入排序
void InsertSort(int A[],int n){
	int i,j,temp;
	for(i = 1;i < n;i++){   // 将各元素插入已排好的序列中
		if(A[i] < A[i-1]){  // 若A[i]关键字小于前驱
			temp = A[i];  // 用temp暂存A[i]
			for(j = i-1;j >= 0 && A[j] > temp;--j) //检查所有前面已排好序的元素
				A[j+1] = A[j];  // 所有大于temp的元素都向后挪位
			A[j+1] = temp;  // 复制到插入位置
		}
	}
}
// 直接插入排序（带哨兵）
void InsertSort(int A[],int n){
	int i,j;
	for(i = 2;i <= n;i++){  // 依次将A[2]~A[n]插入到前面已排序序列
		if(A[i] < A[i-1]){  // 若A[i]关键码小于其前驱，将A[i]插入有序表
		 A[0] = A[i];  // 复制为哨兵 A[0]不存放元素
		 for(j = i-1; A[0] < A[j];--j)  // 从后往前查找待插入位置
		 	A[j+1] = A[j];  // 向后挪位
		 A[j+1] = A[0];  // 复制插入位置
		 }
	}
}
```
**优点**：不用每轮循环都判断 $j>=0$  （不明显）
## 算法逻辑
## 算法性能分析
空间复杂度：$O(1)$
时间复杂度：主要来自对于关键字、移动元素；若有n个元素，则需要n-1趟处理
最好时间复杂度（全部有序）：$O(n)$
最坏时间复杂度（全部逆序）：$O(n^2)$
平均时间复杂度：$O(n^2)$
算法稳定性：稳定
# 希尔排序
## 算法思想
先将待排序表分割成若干形如$L[ i,i+d,i+2d,…,i+kd ]$的特殊子表对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到**d=1**为止
## 算法逻辑
1. 外层循环（`for` 循环）控制步长 `d` 的变化，初始步长 `d` 为数组长度的一半（`n / 2`），然后逐渐减小步长直到 `d` 为1。
2. 内层循环（第二个 `for` 循环）从 `i = d` 开始，表示每一趟希尔排序的起始位置。
3. 在每一趟希尔排序中，通过比较相隔 `d` 位置的元素（`A[i]` 和 `A[i - d]`），判断它们是否处于逆序状态，即前一个元素大于后一个元素。
4. 如果发现逆序，就执行交换操作（使用 `temp` 变量），将较大的元素向后挪位，直到找到合适的插入位置。
5. 在内层循环中，还会通过逐渐减小 `j` 的值（`j = i - d`），继续比较和交换元素，直到插入位置找到为止。
6. 外层循环控制了每一趟的排序过程，它的步长逐渐减小，因此在最后一趟排序中，步长为1，实际上就是一次普通的插入排序，但由于之前的排序已经部分有序，所以效率较高。
7. 随着外层循环的执行，步长 `d` 不断减小，直到 `d` 等于1，表示最后一趟排序，这时整个数组已经有序。
这个算法的核心思想是通过多趟的排序，先将相隔较远的元素进行局部排序，然后逐渐缩小步长，最终完成整个数组的排序。希尔排序的时间复杂度取决于步长序列的选择，通常情况下介于 O(n log n) 和 O(n^2) 之间，性能相对于普通的插入排序要好。
## 算法实现
```C
// 希尔排序
void ShellSort(int A[], int n) {
	int d, i, j;
	for (d = n / 2;d >= 1; d = d / 2)  // 步长变化
		for (i = d;i < n;i++)
			if (A[i] < A[i - d]) {  // 需将A[i]插入有序增量子表
				int temp = A[i];  // 暂存在temp
				for (j = i - d;j >= 0 && temp < A[j];j-=d)  // 
					A[j + d] = A[j];  // 记录后移，查找插入的位置
				A[j + d] = temp;  // 插入
			}
}
```
## 算法性能分析
**空间复杂度**：$O(1)$
**时间复杂度**：和增量序列$d_1,d_2,d_3,…$的选择有关，最坏时间复杂度为$O(n^2)$，当$n$在某个范围时，可达$O(n^{1.3})$
**稳定性**：不稳定
**适用性**：仅适用于顺序表，不适用于链表
# 冒泡排序
## 算法思想
1. 从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即$A[i-1]>A[i]$），则交换它们，直到序列比较完。称这样的过程为“一趟”冒泡排序。
2. 每一趟排序都可以使一个元素移动到最终位置，已经确定最终位置的元素在之后的处理中无需再对比。
3. **如果某一趟排序过程中未发生交换，则算法可以提前结束**。
## 算法逻辑
1. 外层循环（`for` 循环）从 `i = 0` 开始，逐渐增加 `i`，表示每一趟冒泡排序的起始位置。
2. 在每一趟冒泡排序中，内层循环（第二个 `for` 循环）从数组的最后一个元素开始（`j = n - 1`），向前遍历到当前趟的起始位置（`j > i`）。
3. 在内层循环中，通过比较相邻的两个元素（`A[j - 1]` 和 `A[j]`），判断它们是否处于逆序状态，即前一个元素大于后一个元素。
4. 如果发现逆序，就执行交换操作（使用 `Swap` 函数），将较大的元素移到后面，以实现升序排序。
5. 在一趟冒泡排序过程中，如果发生了任何交换操作，将 `flag` 设置为1，表示发生了交换。
6. 如果一趟冒泡排序结束后，`flag` 仍然为0，说明在这一趟中没有发生任何交换，即数组已经是有序的，可以提前结束排序。
7. 外层循环继续增加 `i`，重复以上步骤，直到整个数组排序完成。
这个算法的核心思想是通过多趟的遍历，每次将最大的元素不断地冒泡到数组的末尾。如果一趟遍历中没有发生任何交换，就说明数组已经有序，可以提前结束排序，从而减少不必要的比较和交换操作。这是冒泡排序的优化之一，称为 "提前终止"。
## 算法实现
```C
// 交换
void Swap(int *a, int *b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
// 冒泡排序 (从后往前冒泡)
void BubbleSort(int A[], int n) {
	for (int i = 0;i < n - 1;i++) {
		int flag = 0; // 表示本趟冒泡是否发生交换的标志
		for(int j = n-1; j > i; j--)  // 一趟冒泡过程
			if (A[j - 1] > A[j]) {  //  若为逆序
				Swap(&A[j - 1],&A[j]);  //  交换
				flag = 1;
			}
		if (flag == 0)
			return;  // 本趟遍历后没有发生交换，说明表已经有序
	}
}
```
## 算法性能分析
空间复杂度：$O(1)$
时间复杂度：最好情况：$O(n)$，最坏情况：$O(n^2)$
平均时间复杂度：$O(n^2)$
稳定性：稳定
# 快速排序
## 算法思想
在待排序表$L[1…n]$中任取一个元素$pivot$作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划为独立的两部分$L[1…K-1]$和$L[K+1…n]$，使得$L[1…K-1]$中所有元素都小于$pivot$，$L[K+1…n]$中的所有元素大于等于$pivot$，则$pivot$放在了其最终位置上$L(K)$上，这一过程称为划分。然后分别递归地对两个子表重复上述过程，直至每部分只有一个元素或空为止，即所有元素放在了其最终位置上。
## 算法逻辑
1. `Partition` 函数用于选取枢轴元素，并将待排序序列划分为两个部分，左边的部分包含小于等于枢轴的元素，右边的部分包含大于枢轴的元素。
2. 在 `Partition` 函数中，首先选取第一个元素 `A[low]` 作为枢轴元素的值，将其存储在变量 `pivot` 中。
3. 使用两个指针 `low` 和 `high` 分别指向待排序序列的首尾元素。
4. 然后，通过两个内层的 `while` 循环，不断移动指针 `high` 和 `low`，直到找到需要交换的元素。`high` 从右向左移动，找到小于枢轴的元素，`low` 从左向右移动，找到大于枢轴的元素。
5. 一旦找到需要交换的元素，就执行交换操作，将 `A[high]` 和 `A[low]` 交换位置。
6. 重复执行步骤4和步骤5，直到 `low` 不小于 `high`。
7. 最后，将枢轴元素 `pivot` 放置在最终位置 `low` 上，此时枢轴左侧的元素都小于等于枢轴，右侧的元素都大于枢轴。`low` 即为枢轴的最终位置。
8. 接着，递归地调用 `QuickSort` 函数对枢轴左侧和右侧的子序列进行快速排序，直到整个数组有序。
快速排序是一种高效的排序算法，平均时间复杂度为 O(n*log(n))，它利用了分治的思想，将大问题分解为小问题，通过逐步缩小问题规模来实现排序。它的性能通常优于冒泡排序和选择排序等简单排序算法。
## 算法实现
```C
// 用第一个元素将待排序序列划分为左右两个部分
int Partition(int A[], int low, int high) {
	int pivot = A[low];  // 第一个元素作为枢轴
	while (low < high) {  // 用low和high搜索枢轴的最终位置
		while (low < high && A[high] >= pivot) --high;   
		A[low] = A[high];  // 比枢轴小的元素移到左端
		while (low < high && A[low] <= pivot) ++low;  
		A[high] = A[low];  // 比枢轴大的元素移动到右端
	}
	A[low] = pivot;  // 枢轴元素存放到最终位置
	return low;  // 返回存放枢轴的最终位置
}
// 快速排序
void QuickSort(int A[], int low, int high) {
	if (low < high) {  // 递归跳出的条件
		int pivotpos = Partition(A, low, high);  // 划分
		QuickSort(A, low, pivotpos - 1);  // 划分左子表
		QuickSort(A, pivotpos + 1, high);  // 划分右子表
	}
}
```
![QuickSort.gif](https://blog-1310087999.cos.ap-nanjing.myqcloud.com/v2-c411339b79f92499dcb7b5f304c826f4_b.gif)
## 算法性能分析空间复杂度：O(递归层数)$        最好：O(log_2{n})$     最坏：O(n)$
时间复杂度：$O(n*递归层数)$ 最好：$O(nlog_2{n})$ 最坏：$O(n^2)$
平均时间复杂度：$O(nlog_2{n})$
最好情况时：每次选的枢轴元素都能将序列划分成均匀的两部分
最坏情况时：若序列原本就有序或逆序，则时、空复杂度最高（可优化，尽量选择可以把数据中分的枢轴元素）
稳定性：不稳定
# 选择排序
## 算法思想
每一趟在待排序元素中选取关键字最小的元素加入有序子序列
## 算法逻辑
1. 外层循环（第一个 `for` 循环）从 `i = 0` 开始，逐渐增加 `i`，表示每一趟选择排序的起始位置。
2. 在每一趟选择排序中，假设当前起始位置 `i` 的元素为最小元素，将 `min` 初始化为 `i`，用于记录最小元素的位置。
3. 内层循环（第二个 `for` 循环）从 `j = i + 1` 开始，表示在未排序的部分中寻找最小元素。
4. 在内层循环中，通过比较当前元素 `A[j]` 与最小元素 `A[min]`，判断是否找到了更小的元素。
5. 如果 `A[j]` 小于 `A[min]`，就更新 `min` 的值为 `j`，表示找到了更小元素的位置。
6. 内层循环遍历完成后，`min` 变量中记录的是当前未排序部分中的最小元素的位置。
7. 如果 `min` 的值不等于起始位置 `i`，说明找到了比 `A[i]` 更小的元素，就执行交换操作（使用 `Swap` 函数），将最小元素交换到起始位置 `i`，从而完成一趟选择排序。
8. 外层循环继续增加 `i`，重复以上步骤，直到整个数组排序完成。
这个算法的核心思想是在每一趟排序中选择未排序部分的最小元素，将其放置在已排序部分的末尾，逐渐扩大已排序部分的范围，直到整个数组排序完成。选择排序的时间复杂度为 O(n^2)，因为它每次都需要找到未排序部分的最小元素。它的优点是不需要额外的内存空间，并且对于小规模的数组来说是一种简单有效的排序方法。
## 算法实现
```C
void SelectSort(int A[], int n) {
	for (int i=0; i < n - 1;i++) {  // 一共进行n-1趟
		int min = i;  // 记录最小元素位置
		for (int j = i + 1;j < n;j++)  // 在A[i…n-1]中选择最小的元素
			if (A[j] < A[min]) min = j;  // 更新最小元素位置
		if (min != i) Swap(&A[i], &A[min]);  // 封装的Swap()函数共移动元素3次
	}
}
```
## 算法性能分析
空间复杂度：$O(1)$
时间复杂度：$O(n^2)$
稳定性：不稳定
适用性：既可以用于顺序表，也可用于链表
# 堆排序
## 算法思想
## 算法实现
```C
// 将以K为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len) {
	int temp = A[k];  // 暂存子树的根节点
	for (int i = 2 * k + 1; i < len; i = 2 * i + 1) {  // 沿key较大的子节点向下筛选
		if (i + 1 < len && A[i] < A[i + 1]) 
			i++;  // 取key较大的子节点的下表
		if (temp >= A[i])  
			break;  // 筛选结束
		else {
			A[k] = A[i];  //将A[i]的值调整到双亲节点上
			k = i;  // 修改k值，以便继续向下筛选
		}
	}
	A[k] = temp;  // 被筛选节点的值放入最终位置
}
// 建立大根堆
void BuildMaxHeap(int A[], int len) {
	for (int i = len / 2 - 1; i >= 0; i--)  // 从后往前调整所有非终端结点
		HeadAdjust(A, i, len);
}
// 堆排序的完整逻辑
void HeapSort(int A[], int len) {
	BuildMaxHeap(A, len);  // 初始建堆
	for (int i = len - 1; i > 0; i--) {  // n-1趟的交换和建堆过程
		Swap(&A[i], &A[0]);  // 堆顶元素和堆底元素交换
		HeadAdjust(A, 0, i);  // 把剩余的待排序元素整理成堆
	}
}
```
## 算法性能分析
建堆时时间复杂度：$O(n)$
排序时时间复杂度不超过：$O(h)=O(log_2{n})$
堆排序的时间复杂度：$O(n)+O(nlog_2{n})=O(nlog_2{n})$
空间复杂度：$O(1)$
稳定性：不稳定
# 归并排序
## 算法思想
把两个或多个已经有序的序列合并成一个
## 算法实现
```C
 int *B = (int*)malloc((high - low + 1) * sizeof(int));
//int B[8] = {0,0,0,0,0,0,0,0};
// A[low…mid]和A[mid…high]各自有序，将两个部分归并
void Merge(int A[], int low, int mid, int high) {
	int i, j, k;
	for (k = low;k <= high;k++)
		B[k] = A[k];
	for (i = low, j = mid + 1, k = i;i <= mid && j <= high;k++) {
		if (B[i] <= B[j]) 
			A[k] = B[i++];  // 将较小值复制到A中
		else 
			A[k] = B[j++];
	}
	while (i <= mid) A[k++] = B[i++];
	while (j <= high) A[k++] = B[j++];
}
void MergeSort(int A[], int low, int high) {
	if (low < high) {
		int mid = (low + high) / 2;  // 从中间划分
		MergeSort(A, low, mid);  // 对左半部分归并排序
		MergeSort(A, mid + 1, high);  // 对右半部分归并排序
		Merge(A, low, mid, high);  //  归并
	}
}
```
## 算法逻辑

## 算法效率分析
时间复杂度：$O(nlog_2{n})$
空间复杂度：$O(n)$
稳定性：稳定
# 计数排序
## 算法思想
统计原来数组的数据，并将数据转换成下标存储于一个临时的空间中，然后变量临时空间把对应的下表值放回原数组，当遍历临时空间完成后，原来的数组就是排好序了。
## 算法逻辑
1. 首先定义了一个大小为 `N` 的数组 `B`，用于辅助排序。数组 `B` 用来统计输入数组 `A` 中每个元素的出现次数。
2. 第一个 `for` 循环遍历数组 `A`，对每个元素进行计数，具体做法是将元素的值作为索引，将 `B[A[i]]` 的值增加1，表示该元素出现了一次。
3. 第二个 `for` 循环用来将排序好的元素重新放回数组 `A` 中。在循环中，首先检查 `B[i]` 的值，表示元素 `i` 出现的次数。
4. 然后，使用一个内部的 `while` 循环，将元素 `i` 重复放入数组 `A` 中 `B[i]` 次，从而确保相同的元素连续出现在排序后的数组中。
5. 外层循环继续增加 `i`，重复以上步骤，直到遍历完数组 `B` 中的所有元素。
计数排序的核心思想是通过统计每个元素的出现次数，然后根据计数结果重建排序后的数组。这个算法适用于待排序元素具有一定范围的情况，例如整数排序。计数排序的时间复杂度为 O(n+k)，其中 n 是输入元素的个数，k 是元素的范围，因此在范围不大的情况下，它是一种高效的排序算法。但需要注意的是，计数排序是一种稳定的排序算法。
## 算法实现
```C
#define N 10
int B[N];
void CountSort(int A[], int n) {
	for (int i = 0;i < n;i++)
		B[A[i]]++;
	for (int i = 0, j = 0;i < N;i++)
		while (B[i]--)
			A[j++] = i;
}
```
# 基数排序
## 算法思想
## 算法实现
```C
int B[10][8];
void RedixSort(int A[], int n) {
	int i ,j, pos;
	for (int k = 10;k < 10000;k *= 10) {
		for (int i = 0;i < n;i++) {
			int j = 0;
			int pos = (A[i] % k) / (k / 10);
			while (B[pos][j])
				j++;
			B[pos][j] = A[i];
		}
		int pos = 0;
		for (int i = 0;i < 10;i++) {
			for (j = 0;j < n&&B[i][j]!=0;j++) {
				if (B[i][j] != 0) {
					A[pos++] = B[i][j];
					B[i][j] = 0;
				}
			}
		}
	}
}
```
# 桶排序
## 算法思想
1. 确定桶的数量：首先，根据待排序数据的范围确定需要的桶的数量。通常情况下，桶的数量可以根据数据范围的最大值和最小值来确定。
2. 将数据分配到桶中：将待排序的数据遍历一次，并根据每个数据项的值将其分配到对应的桶中。具体的分配方法可以根据数据值和桶的范围进行映射计算。
3. 对每个桶内的数据进行排序：对每个桶内的数据进行排序，可以使用任何适合的排序算法，通常选择快速排序、插入排序等。
4. 合并桶：将排序后的每个桶内的数据按照顺序合并起来，形成最终有序的结果。
## 算法逻辑
1. `int* buckets[100];`：定义一个包含100个指针的数组，这些指针将用于表示桶。每个桶都可以容纳多个相同值的元素。
2. `for (int i = 0; i < 100; i++) { buckets[i] = 0; }`：初始化桶数组，将每个桶的指针初始化为0，表示每个桶最初为空。
3. `for (int i = 0; i < n; i++) {`：开始遍历待排序的数组 `A`。
4. `int index = A[i];`：将当前元素 `A[i]` 的值作为桶的索引。这里假设数据范围在0到99之间，因此将元素值作为桶的索引是合理的。
5. `buckets[index]++;`：增加索引为 `index` 的桶中元素的个数，表示将当前元素放入相应的桶中。
6. `int index = 0;`：初始化一个用于遍历原数组的索引。
7. `for (int i = 0; i < 100; i++) {`：开始遍历所有的桶，从0到99。
8. `while (buckets[i] > 0) {`：进入一个循环，这个循环用于将桶中的元素取出并放回原数组中。
9. `A[index++] = i;`：将桶的索引值 `i` 放入原数组 `A` 中，并递增索引 `index` 以指向下一个位置。
10. `buckets[i]--;`：减少索引为 `i` 的桶中元素的个数，表示一个元素已被取出。
通过上述逻辑，代码实现了桶排序的核心思想，将元素分配到桶中，然后从每个桶中按照顺序将元素取出，最终得到有序的结果。需要注意的是，这个示例中假设待排序的元素范围在0到99之间，因此创建了100个桶来表示每个可能的元素值。如果实际情况中元素范围更大，桶的数量需要相应增加。
## 算法实现
```C
// 桶排序函数
void BucketSort(int A[], int n) {
    // 假设数据范围在0到99之间，创建包含100个桶的数组
    int* buckets[100];
    // 初始化桶数组中的每个元素为0
    for (int i = 0; i < 100; i++) {
        buckets[i] = 0;
    }
    // 将元素放入桶中
    for (int i = 0; i < n; i++) {
        int index = A[i];
        // 计算桶中元素的个数
        buckets[index]++;
    }
    // 从桶中取出数据，按顺序放回原数组中
    int index = 0;
    for (int i = 0; i < 100; i++) {
        while (buckets[i] > 0) {
            A[index++] = i;
            buckets[i]--; // 减少桶中元素的个数
        }
    }
}
```
## 算法性能分析
==空间复杂度==：$O(n+k)$
时间复杂度：最好情况：$O(n)$  最坏情况：$O(n^2)$
==平均时间复杂度==：$O(n+k)$
稳定性：稳定
